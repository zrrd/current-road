* Thread1 一个简单的线程
* Thread2 不要通过stop结束线程 通过方法让他结束
* Thread3 interrupt() 通过线程中断退出线程
* Thread4 wait 和 notify 多线程协作
* Thread5 Thread.join() 线程的等待
* Thread6 线程组
* Thread7 守护线程 Daemon
* Thread8 线程的优先级
* Thread9 synchronized线程安全
* sleep 方法不会释放资源监视器 但是会让出CPU资源
* Thread10 yield 让出CPU
* Thread11 volatile 可见性

---
* SpuriousWakeup 线程的虚假环境与避免线程的虚假唤醒
* 上下文切换 
> 多任务系统往往需要同时执行多道作业。作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，
如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者 巧妙地利用了时间片轮转的方式, 
CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。
任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。
* 死锁产生的条件
> * 互斥条件: 一个资源每次只能被一个进程使用。
> * 占有且等待: 一个进程因请求资源而阻塞时，对已获得的资源保持不放。
> * 不可剥夺条件: 进程已获得的资源，在末使用完之前，不能强行剥夺。
> * 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。
> 如何避免死锁 : 对多个资源同时加锁时 , 需要保证一致的加锁顺序